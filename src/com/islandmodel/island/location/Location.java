package com.islandmodel.island.location;import com.islandmodel.entitie.animal.Animal;import java.util.ArrayList;import static com.islandmodel.Config.ENTITIES_INITIAL_QUANTITY;import static com.islandmodel.utils.Randomizer.getRandom;public class Location {    // Списки где будут хранитсья находящиеся на локации сущности    private EntitiesToLocation entitiesToLocation = new EntitiesToLocation();    private final Coordinate coordinate;//нужен только для ту стринга    private final ArrayList<Coordinate> nearbyLocations;    public Location(int coordinateCol, int coordinateRow) {        this.coordinate = Coordinate.newCoordinate(coordinateCol, coordinateRow);        this.nearbyLocations = new ArrayList<>();    }    public Coordinate getCoordinate() {        return coordinate;    }    public ArrayList<Coordinate> getNearbyLocations() {        return nearbyLocations;    }    public void setNearbyLocations(ArrayList<Coordinate> nearbyLocations) {        this.nearbyLocations.addAll(nearbyLocations);    }    public EntitiesToLocation getEntitiesToLocation() {        return entitiesToLocation;    }    public void setEntitiesToLocation(EntitiesToLocation entitiesToLocation) {        this.entitiesToLocation = entitiesToLocation;    }    public void initializeAnimal(int typeOfAnimalToCreate) {        getEntitiesToLocation().initializeAnimal(typeOfAnimalToCreate);//        for (int i = 0; i < ENTITIES_INITIAL_QUANTITY.length; i++) {//перебираем виды животных//            for (int j = 0; j < ENTITIES_INITIAL_QUANTITY[i]; j++) {////            }//        }//        int maxCountPredators = 5;//        int maxCountHerbivores = 10;////        for (int i = 0; i < maxCountPredators; i++) {//            int animalType = getRandom(5);//            Animal predator = returnNewAnimal(animalType);////            locations.get(Coordinate.newCoordinate(ThreadLocalRandom.current().nextInt(WIDTH),//                            ThreadLocalRandom.current().nextInt(HEIGHT)))//                    .addAnimalToLocation(predator);//        }////        for (int i = 0; i < maxCountHerbivores; i++) {//            int animalType = getRandom(5, 15);//            Animal herbivore = returnNewAnimal(animalType);//            locations.get(newCoordinate(getRandom(WIDTH), getRandom(HEIGHT))).addAnimalToLocation(herbivore);//        }////        for (int ix = 0; ix < WIDTH; ix++) {//            for (int iy = 0; iy < HEIGHT; iy++) {////                int amountPlantToLocation = locations.get(newCoordinate(ix, iy)).getPlantsSizeToLocation();//                if (amountPlantToLocation == 0) {//                    for (int i = 0; i < 20; i++) {//                        locations.get(Coordinate.newCoordinate(ix, iy)).addPlantToLocation(new Plant());//                    }//                } else {//                    for (int i = 0; i < amountPlantToLocation; i++) {//                        locations.get(Coordinate.newCoordinate(ix, iy)).addPlantToLocation(new Plant());//                    }//                }//            }//        }    }    public void calculate() {//        for (int i = 0; i < entitiesToLocation.getAnimals().size(); i++) {//            Animal animal = entitiesToLocation.getAnimals().get(i);//            if (!animal.isDead()) {//                animal.eat(makeMenu(animal));//            }//        }//        cleaningAnimalsPlantLists();////        //размножение//        for (int typeofAnimal = 0; typeofAnimal < AnimalsType.values().length; typeofAnimal++) {//            int countOfAnimalThisType = 0;//            for (int j = 0; j < entitiesToLocation.getAnimals().size(); j++) {//                if (entitiesToLocation.getAnimals().get(j).getType() == AnimalsType.valueOf(String.valueOf(typeofAnimal))) {//проверить не создается ли тут животное при счетчике равном нулю!!!//                    countOfAnimalThisType++;//                }//            }//            countOfAnimalThisType = (countOfAnimalThisType == Config.MAX_PER_LOCATION[typeofAnimal]) ? 0 : (Config.MAX_PER_LOCATION[typeofAnimal] + countOfAnimalThisType) % Config.MAX_PER_LOCATION[typeofAnimal];///тут проверяем максимальное число на ячейку//            for (int j = 0; j < (countOfAnimalThisType / 2); j++) {///как то нужно ограничить количество на одной ячейке//                entitiesToLocation.getAnimals().add(returnNewAnimal(typeofAnimal));//            }//        }////        //перемещаемся//        for (int i = 0; i < entitiesToLocation.getAnimals().size(); i++) {//            Coordinate endingCoordinate = entitiesToLocation.getAnimals().get(i).chooseDirection(coordinatesToMove(entitiesToLocation.getAnimals().get(i)));////        }    }//    private EntitiesToLocation makeMenu(Animal animal) {//        EntitiesToLocation result = new EntitiesToLocation();//        for (int j = 0; j < entitiesToLocation.getAnimals().size(); j++) {//            if (animal != entitiesToLocation.getAnimals().get(j) && animal.onTheMenu(entitiesToLocation.getAnimals().get(j))) {//                result.getAnimals().add(entitiesToLocation.getAnimals().get(j));//            }//        }//        if (animal instanceof Herbivore) {//            result.getPlants().addAll(entitiesToLocation.getPlants());//        }//        return result;//    }//    public void addAnimalToLocation(Animal animal) {//        entitiesToLocation.getAnimals().add(animal);//    }////    public void addPlantToLocation(Plant plant) {//        entitiesToLocation.getPlants().add(plant);//    }////    public int getPlantsSizeToLocation() {//        return entitiesToLocation.getPlants().size();//    }//    private void cleaningAnimalsPlantLists() {//        for (int i = 0; i < entitiesToLocation.getAnimals().size(); i++) {//            if (entitiesToLocation.getAnimals().get(i).isDead()) {//                entitiesToLocation.getAnimals().remove(i);//                i--;//            }//        }//        for (int i = 0; i < entitiesToLocation.getPlants().size(); i++) {//            if (entitiesToLocation.getPlants().get(i).isBitten()) {//                entitiesToLocation.getPlants().remove(i);//                i--;//            }//        }//    }//    public static Animal returnNewAnimal(int random) {//        Animal animal = switch (random) {//            case 0 -> new Bear();//            case 1 -> new Boa();//            case 2 -> new Eagle();//            case 3 -> new Fox();//            case 4 -> new Wolf();//            case 5 -> new Boar();//            case 6 -> new Buffalo();//            case 7 -> new Caterpillar();//            case 8 -> new Deer();//            case 9 -> new Duck();//            case 10 -> new Goat();//            case 11 -> new Horse();//            case 12 -> new Mouse();//            case 13 -> new Rabbit();//            default -> new Sheep();//        };//        return animal;//    }    //    public ArrayList<Coordinate> coordinatesToMove(Animal animal) {//        int x = coordinate.getX();//        int y = coordinate.getY();//        int travelDistance = Config.TRAVEL_DISTANCE[animal.getType().ordinal()];//        ArrayList<Coordinate> result = new ArrayList<>();////        for (int i = -travelDistance; i <= travelDistance; i++) {//            for (int j = -travelDistance; j <= travelDistance; j++) {//                if (0 <= i && i < Config.WIDTH && 0 <= j && j < Config.HEIGHT) {//                    result.add(Coordinate.newCoordinate(i, j));//                }//            }//        }//        return result;//нужно сделать чтобы возвращал координату через методы самого животного может какое нибудь житвотное боится кого нибудь и не хочет туда телепортироватся)))//    }    public String toString() {        return coordinate.toString() + " " + entitiesToLocation.toString();    }}